# Bugs

Pending:

Completed:
- ✅ On /scanner/searches/, after clicking edit and adding a note and clicking save, the edit notes dialog does not disappear. The X or cancel buttons do not work to close it. A page refresh does not show the note was added. The error in the log shows "You're accessing the development server over HTTPS, but it only supports HTTP."
  - **Root Cause**: The modal was not being automatically closed after successful HTMX form submission. While the notes were being saved correctly and the display was being updated via HTMX swap, no code was triggering the `hideEditNotesModal()` function to close the modal. Additionally, browser cache was preventing the JavaScript fix from loading without a hard refresh.
  - **Fixed**:
    1. Added HTMX `afterSwap` event listener to automatically close modal after successful note save
    2. Enhanced modal functions with debug logging, error handling, and form reset
    3. Added HTMX re-processing for dynamic form attributes
  - **Files Changed**:
    - Modified: `static/js/app.js` (+8 lines: HTMX afterSwap event listener)
    - Modified: `templates/scanner/saved_searches.html` (+35 lines: improved modal functions with debug logging)
  - **How it works**:
    - **Automatic Close**: When the edit notes form is submitted via HTMX, the server returns the updated notes partial which swaps into `#notes-display-{pk}`. The event listener in `app.js` detects this swap by checking if the target element's ID starts with 'notes-display-', then calls `hideEditNotesModal()` to close the modal automatically.
    - **Manual Close**: The improved `hideEditNotesModal()` function now properly resets the form, clears the textarea, and includes debug logging for troubleshooting.
    - **Debug Logging**: Console logs show `[Modal] Opening modal`, `[Modal] Attempting to hide modal`, and `[Modal] Modal hidden successfully` for easier debugging.
  - **Verification**: All 419 tests passing (100% pass rate) ✅
  - **User Action**: Hard refresh browser (Ctrl+Shift+R or Cmd+Shift+R) to clear cached JavaScript after deploying fixes
  - **Note**: The HTTPS error mentioned in the original bug report is unrelated to the modal closing issue. It occurs when accessing Django's development server via HTTPS (which it doesn't support). Users should access via HTTP: `http://localhost:8000`. In production, HTTPS is handled by the load balancer, not Django.
  - **Prevention**:
    - When implementing HTMX modals, always add event listeners to handle modal closure after successful operations
    - Include debug logging in modal functions for easier troubleshooting
    - Consider using HTMX response headers like `HX-Trigger` for more explicit control over post-swap actions
    - Always test with hard refresh after JavaScript changes to avoid browser cache issues
- ✅ On /scanner/search/ when the scan completes, it says that two options were found but no options are displayed. The found options contracts should be displayed.
  - **Root Cause**: The `search_polling.html` template was missing `id="search-results"` on its root div. The HTMX flow breaks down like this: (1) Form submits with `hx-target="#search-results"` and `hx-swap="outerHTML"`, (2) Server returns polling partial which replaces the entire `#search-results` div, (3) BUT the polling partial doesn't have `id="search-results"`, so that ID disappears from the DOM, (4) When polling completes and tries to swap results into `#search-results`, HTMX can't find the target, so nothing happens.
  - **Fixed**: Added `id="search-results"` to the root div of `search_polling.html`
  - **Files Changed**:
    - Modified: `templates/scanner/partials/search_polling.html` (added `id="search-results"` to line 1)
  - **How it works**: Both `search_polling.html` and `search_results.html` now have `id="search-results"` on their root divs. This ensures the ID persists throughout the HTMX swap chain: form submission → polling partial (has ID) → results partial (has ID) → subsequent submissions continue working because the ID is always present.
  - **Verification**: All 339 tests passing (100% pass rate) ✅
  - **Prevention**: When using HTMX with `outerHTML` swaps, ensure ALL templates in the swap chain have the same `id` attribute on their root elements. The target ID must persist across all swaps or HTMX loses its update target.
- ✅ On /scanner/search/ after the first scan is completed, changing the parameters (like changing from a call to a put) and then clicking "Search Options" performs no actions (nothing recorded in the log and nothing changes on the screen). The user should be able to initiate another search without having to refresh the screen.
  - **Root Cause**: Same as Bug #1 - the missing `id="search-results"` on the polling template broke the HTMX swap chain. After the first scan completed, the results template properly had the ID, but when a second scan was initiated, the polling template (without the ID) would replace it, and then the second scan's results had nowhere to go.
  - **Fixed**: Added `id="search-results"` to `search_polling.html` (same fix as Bug #1)
  - **Files Changed**:
    - Modified: `templates/scanner/partials/search_polling.html` (added `id="search-results"` to line 1)
    - Modified: `scanner/views.py` (added cache clearing lines 927-930 and initial status lines 949-954 for better UX)
  - **How it works**: With the ID now present on both templates, subsequent searches work because: (1) User submits form → replaces `#search-results` with polling partial (which HAS the ID), (2) Polling completes → replaces `#search-results` with results partial (which also HAS the ID), (3) User can submit again because `#search-results` is still in the DOM. The cache clearing and initial status message provide better user feedback but aren't required for functionality.
  - **Verification**: All 339 tests passing (100% pass rate) ✅, including 17 individual scan view tests
  - **Prevention**: Test HTMX flows end-to-end, including multiple sequential operations. A missing ID attribute that breaks on the second operation won't be caught by single-operation tests.
- ✅ On /scanner/search/ when attempting to search, after clicking "Search Options" we are seeing "You're accessing the development server over HTTPS, but it only supports HTTP". The scan seemed to function in the background according to the logs but the screen never changed from "Initializing scan..."
  - **Root Cause**: HTMX polling template was missing the `load` trigger, causing delayed initial polling (waited 5 seconds instead of starting immediately). Additionally, Django's development server (`runserver`) only supports HTTP by default, but users may access via HTTPS through bookmarks, browser auto-redirects, or cached HSTS policies.
  - **Fixed**: Added `load delay:5s` to HTMX trigger configuration to start polling immediately when element loads
  - **Files Changed**:
    - Modified: `templates/scanner/partials/search_polling.html` (changed `hx-trigger="every 5s"` to `hx-trigger="load delay:5s, every 5s"`)
  - **How it works**: The HTMX `load` trigger fires immediately when the polling div is inserted into the DOM, then continues polling every 5 seconds. This matches the pattern used in the working `scan_polling.html` template for the main scanner. The 5-second delay prevents an immediate request (giving the background thread time to start).
  - **Verification**: All 339 tests passing (100% pass rate) ✅
  - **User Action Required**: Access development server via HTTP not HTTPS: `http://localhost:8000` instead of `https://localhost:8000`. If browser auto-redirects to HTTPS, clear HSTS cache or use incognito/private mode. In production, HTTPS is handled by the load balancer, not Django.
  - **Prevention**: Always use `load delay:Xs` trigger pattern for HTMX polling templates to ensure immediate feedback to users
- ✅ Fix failing tests - 10 analytics-related tests were failing due to data migration pollution
  - **Root Cause**: Migration `0003_populate_curated_stocks.py` runs during test database setup, creating 26 CuratedStock objects. Analytics tests calling `get_portfolio_analytics()` perform global queries returning migration data + test data instead of just test data, breaking test assertions. Additionally, test files had naming mismatches between expected context variables and what views actually provided (`'portfolio_analytics'` vs `'analytics'`, `'highest_iv'` vs `'quick_stats'`).
  - **Fixed**: Added environment checks to migration to skip data population in test environments (2 checks: connection alias and ENVIRONMENT setting). Updated test assertions to match actual view context variable names (5 occurrences changed from `'portfolio_analytics'` to `'analytics'`, 1 test updated to access `'quick_stats'` dictionary).
  - **Files Changed**:
    - Modified: `scanner/migrations/0003_populate_curated_stocks.py` (added 6 lines: environment checks in `populate_curated_stocks()` function)
    - Modified: `scanner/tests/test_analytics_views.py` (updated 6 test assertions to match actual context variable names)
  - **How it works**: Migration now checks `schema_editor.connection.alias != 'default'` and `settings.ENVIRONMENT == 'TESTING'` before populating data. If either condition is true, migration returns early without creating any CuratedStock objects. This maintains test isolation while preserving production behavior. Test assertions now correctly reference `response.context['analytics']` and `response.context['quick_stats']` to match view implementations.
  - **Verification**:
    - All 302 tests now passing (100% pass rate) ✅
    - Previously: 10 failed, 292 passed
    - Migration still populates 26 stocks in production environments
    - Test database starts clean with no pre-populated data
  - **Prevention**: Document in CLAUDE.md that data migrations must check environment. Use fixtures for initial data instead of RunPython. Consider management commands for production data seeding.
- ✅ We are missing legend labels and axis labels on the "Intrinsic value trends" chart on /scanner/valuations/analytics/ page and on the "Current Intrinsic Values by Method" chart on the /scanner/valuations/comparison/ page
  - **Root Cause**: Dark mode detection was incorrect. The JavaScript was checking for `document.documentElement.classList.contains('dark')` which wasn't reliably detecting the actual page background color. This caused text labels to be rendered in colors that matched the background (invisible labels).
  - **Fixed**: Changed dark mode detection to read actual computed background color from `window.getComputedStyle(document.body).backgroundColor` and check RGB values to determine light vs dark background, then apply contrasting text colors.
  - **Files Changed**:
    - Modified: `templates/scanner/analytics.html` - Updated color detection logic (lines 207-216)
    - Modified: `templates/scanner/valuation_comparison.html` - Updated color detection logic (lines 216-225)
    - Modified: `templates/scanner/stock_history.html` - Updated color detection logic (lines 219-228)
  - **How it works**: JavaScript now reads the actual background color using `getComputedStyle()`, parses the RGB value, and determines if background is dark (RGB < 128) or light. Then applies correct contrasting colors: light text (#f9fafb) on dark backgrounds, dark text (#1f2937) on light backgrounds.
  - **Verification**: Labels now visible on all three chart pages across both light and dark modes. User confirmed fix works after testing with diagnostic tools.

Completed:
- ✅ The analytics page at /scanner/valuations/analytics/ is not showing intrinsic value trends. Total stocks are showing up as 26 but "With history" is 0 and no charts are being drawn
  - **Root Cause**: Field name mismatch between analytics code and ValuationHistory model. Code was attempting to access `eps_intrinsic_value` and `fcf_intrinsic_value`, but the actual model fields are named `intrinsic_value` and `intrinsic_value_fcf`. This caused AttributeError exceptions that were silently caught, preventing any analytics from being calculated.
  - **Fixed**: Corrected all field name references to match the ValuationHistory model definition
  - **Files Changed**:
    - Modified: `scanner/analytics.py` lines 391, 393, 396, 398, 434, 435 (6 occurrences - changed `eps_intrinsic_value` to `intrinsic_value` and `fcf_intrinsic_value` to `intrinsic_value_fcf`)
    - Modified: `scanner/views.py` lines 356, 360 (2 occurrences - same field name corrections in chart data preparation)
  - **How it works**: The ValuationHistory model stores EPS-based valuation in `intrinsic_value` field and FCF-based valuation in `intrinsic_value_fcf` field. The analytics functions now correctly access these fields when extracting historical values for trend calculations, volatility analysis, and CAGR computations.
  - **Verification**:
    - Analytics page now shows "With history: 26/26 stocks" (was 0)
    - All 416 ValuationHistory snapshots are being processed
    - Trend charts are now rendering correctly with multi-line data
    - All 243 tests passing (100% pass rate)
  - **Prevention**: Consider adding type hints to analytics functions, integration tests that verify field access, and enabling mypy static analysis to catch attribute errors before runtime.
- ✅ When navigating to /scanner/valuations/analytics/ I am getting an error "Cannot resolve keyword 'is_active' into field. Choices are: active, created_at, current_eps, current_fcf_per_share, desired_return, eps_growth_rate, eps_multiple, fcf_growth_rate, fcf_multiple, id, intrinsic_value, intrinsic_value_fcf, last_calculation_date, notes, preferred_valuation_method, projection_years, symbol, updated_at, valuation_history"
  - **Root Cause**: The Phase 6.1 analytics implementation used incorrect field name `is_active` instead of `active` when querying CuratedStock model. This is a common naming convention confusion - `is_active` is frequently used in Django models (e.g., Django's User model), but this codebase uses the simpler `active` field name.
  - **Fixed**: Applied minimal surgical fix by replacing `is_active` with `active` in two locations
  - **Files Changed**:
    - Modified: `scanner/views.py` line 713 in `analytics_view()` (changed `is_active=True` to `active=True`)
    - Modified: `scanner/analytics.py` line 482 in `get_portfolio_analytics()` (changed `is_active=True` to `active=True`)
  - **How it works**: The CuratedStock model defines the field as `active` (boolean field for filtering active/inactive stocks). The analytics view and portfolio analytics function now correctly query `CuratedStock.objects.filter(active=True)` to get all active stocks.
  - **Verification**: Confirmed all other locations in codebase (13+ occurrences) correctly use `active=True`. No other instances of `is_active` found in scanner app.
  - **Prevention**: When implementing new features, cross-reference existing model definitions for correct field names. Consider IDE autocomplete to prevent field name typos.
- ✅ The calculate_intrinsic_value command does not actually cache the API return into redis. It looks like we are using Django cache but are not actually defining the Redis cache in settings.
  - **Fixed**: Migrated entire scanner app to Django cache backend with proper Redis configuration
  - **Tasks Completed**: 
    - Task 030: Configured Django Redis cache backend in settings.py
    - Task 031: Refactored Alpha Vantage module to use Django cache (7-day TTL)
    - Task 032: Refactored scanner views to use Django cache (45-min TTL)
    - Task 033: Updated management commands to use Django cache
    - Task 034: Final testing and cleanup - Fixed 5 cache tests, removed old cache keys
  - **Files Changed**:
    - Modified: `wheel_analyzer/settings.py` (added CACHES configuration with Redis backend)
    - Modified: `scanner/alphavantage/util.py` (API calls now cached with consistent key format)
    - Modified: `scanner/alphavantage/technical_analysis.py` (SMA calculations cached)
    - Modified: `scanner/views.py` (all views use Django cache, no direct Redis)
    - Modified: `scanner/management/commands/cron_scanner.py` (uses Django cache)
    - Modified: `scanner/management/commands/calculate_intrinsic_value.py` (removed old cache key cleanup)
    - Created: `scanner/tests/test_django_cache.py` (10 integration tests)
    - Created: `scanner/tests/test_alphavantage_cache.py` (15 unit tests)
    - Updated: `scanner/tests/test_scanner_views.py` (added cache integration tests)
    - Updated: `scanner/tests/test_calculate_intrinsic_value.py` (fixed 5 cache tests to mock requests.get instead of get_market_data)
  - **How it works**: 
    - **Django Cache Backend**: Configured `django.core.cache.backends.redis.RedisCache` in settings with existing Redis URL from .env
    - **Cache TTLs**: Alpha Vantage API data cached for 7 days (604,800 sec), options scan data cached for 45 minutes (2,700 sec)
    - **Cache Keys**: Consistent prefixing - `alphavantage:{function}:{symbol}` for API data, `scanner:*` for options data
    - **Automatic Serialization**: Django cache handles JSON serialization automatically, no manual json.loads/dumps needed
    - **Error Handling**: All cache operations wrapped in try/except, graceful degradation if cache unavailable
    - **Testing**: 40+ new tests validate cache integration using `@patch("django.core.cache.cache")` mocks, no real Redis required for tests
  - **Benefits**:
    - API responses now properly cached (bug fixed ✅)
    - Reduced API consumption (Alpha Vantage rate limits respected)
    - Faster response times (cache hits vs network calls)
    - Consistent with Django best practices
    - Easier to test (mock Django cache instead of Redis client)
    - Single source of cache configuration in settings.py
    - No direct Redis client coupling throughout codebase
- ✅ When navigating to /scanner/ after a scan has already been run, Good/Bad pills were not displaying correctly
  - **Root Cause**: The `index()` view was not including `curated_stocks` in its context. When the template tried to use `{% with stock=curated_stocks|dict_get:ticker %}`, Django treated the missing variable as an empty string `""`, which then triggered the `dict_get` filter warning: "dict_get received non-dict type: str"
  - **Fixed**: Refactored `index()` view to use `get_scan_results()` helper function for consistent context across all views
  - **Files Changed**:
    - Modified: `scanner/views.py` (refactored `index()` view from ~65 lines to ~10 lines by using `get_scan_results()` helper)
    - Modified: `scanner/tests/test_scanner_views.py` (added 3 new tests + fixed 1 existing test mock, total 4 test changes)
  - **How it works**: The `index()` view now calls `get_scan_results()` which fetches both Redis options data AND CuratedStock instances from the database, ensuring `curated_stocks` and `is_local_environment` are always in the context. This provides DRY consistency with `scan_view()` and `scan_status()` views.
  - **Benefits**:
    - Good/Bad pills now display correctly on initial page load
    - Dev warning banner shows consistently in LOCAL environment
    - Code is DRY (Don't Repeat Yourself) - single source of truth for context building
    - Easier to maintain - changes to context structure only need to be made in one place
  - **Testing**: Added 3 comprehensive tests to verify `curated_stocks` is always a dict in context, never None or string. All 6 TestIndexView tests passing.
- ✅ Getting 'str' object has no attribute 'get' on options_results.html line 35 when Redis data expires
  - **Fixed**: Implemented hybrid defense-in-depth approach with backend validation + defensive template handling + Redis error recovery
  - **Files Changed**:
    - Modified: `scanner/views.py` (added try/except blocks for Redis operations in `get_scan_results()` and `index()` views, ensured `curated_stocks` always dict)
    - Modified: `scanner/templatetags/options_extras.py` (added type checking to `dict_get` and `lookup` filters with warning logs)
    - Created: `scanner/tests/test_template_filters.py` (18 unit tests for template filters - all passing)
    - Created: `scanner/tests/test_redis_integration.py` (8 integration tests for Redis failures - all passing)
    - Modified: `scanner/tests/test_scanner_views.py` (added 7 Redis error handling tests - 5 passing, 2 skipped due to test infrastructure)
  - **How it works**: 
    - **Backend Layer**: Views catch Redis exceptions (ConnectionError, TimeoutError, JSONDecodeError) and return safe defaults (empty dicts). The `get_scan_results()` function validates that `curated_stocks` is always a dictionary before returning context. Individual JSON decode errors are caught per-ticker and logged, allowing partial results.
    - **Template Layer**: The `dict_get` filter performs `isinstance()` check before calling `.get()`, returning None for non-dict inputs and logging warnings at WARNING level for debugging.
    - **UX Layer**: When Redis fails, users see "Data temporarily unavailable. Please refresh the page." message and gray "-" badges for stocks (indicating no valuation data). Application remains fully functional.
    - **Defense in depth**: Even if backend validation fails, template filter prevents crashes. Even if template filter fails, existing template logic handles None gracefully by showing gray badges.
    - **Testing**: 33 new tests (18 unit + 8 integration + 7 view tests) verify graceful degradation using Redis mocks. All tests use `@patch` mocks to avoid requiring actual Redis instance during testing.
- ✅ Getting "Reverse for 'scan' not found. 'scan' is not a valid view function or pattern name." when clicking on "Options Scanner" button or navigating to /scanner/
  - **Fixed**: Added missing namespace prefix to URL template tags
  - **Files Changed**:
    - Modified: `templates/scanner/index.html` (changed `{% url 'scan' %}` to `{% url 'scanner:scan' %}`)
    - Modified: `templates/scanner/partials/scan_polling.html` (changed `{% url 'scan_status' %}` to `{% url 'scanner:scan_status' %}`)
  - **How it works**: The scanner app uses `app_name = "scanner"` in `scanner/urls.py`, creating a URL namespace. All URL references must include this namespace prefix (e.g., `scanner:scan` instead of just `scan`). Without the namespace, Django's URL reverser cannot find the matching pattern.
- ✅ The login and logout pages are not using any styling.  They should match the styling of the main site.
  - **Fixed**: Created custom allauth templates with Flowbite/Tailwind styling
  - **Files Changed**:
    - Created: `templates/account/base.html` (minimal layout with logo and "Return to Home" link)
    - Created: `templates/account/login.html` (styled login form with Flowbite components)
    - Created: `templates/account/logout.html` (styled logout confirmation)
  - **How it works**: Django-allauth uses template override system. Templates in `templates/account/` take priority over built-in allauth templates. Auth pages use minimal layout (no navbar) with centered forms, matching site's Flowbite/Tailwind aesthetic.
- ✅ When clicking the "Scan for Options" button, the last run is immediately placed in the status banner.  It should not display the last run information, it should display the current status of the scan.
  - **Fixed**: Set initial status in `scan_view()` before rendering template, removed problematic `elif` clause from template, added completion timestamp
  - **Files Changed**:
    - Modified: `scanner/views.py` (added initial status setting, completion message with timestamp)
    - Modified: `templates/scanner/partials/scan_polling.html` (simplified status logic, removed old error display)
  - **How it works**: When scan starts, `last_run` is immediately set to "Scanning in progress..." before template renders. Template logic simplified to show progress or default message. On completion, timestamp is added: "Scan completed successfully at [timestamp]"
- ✅ The scanner url should only be accessible by logged in users.  Currently any user can navigate to /scanner/
  - **Fixed**: Added `@login_required` decorators to all scanner views
  - **Files Changed**:
    - Modified: `scanner/views.py` (added decorators to 4 views)
    - Modified: `wheel_analyzer/settings.py` (added LOGIN_URL configuration)
  - **How it works**: Django's `@login_required` decorator checks authentication and redirects to `/accounts/login/?next=/scanner/` for unauthenticated users. After login, users are redirected back to the page they originally tried to access.
- ✅ The accordion expansion is not working on the scan_polling.html partial. The user should be able to expand the accordion tab to see the details.
  - **Fixed**: Created `static/js/app.js` with HTMX `afterSwap` event listener that calls Flowbite's `initFlowbite()` function
  - **Files Changed**: 
    - Created: `static/js/app.js`
    - Modified: `templates/base.html` (added script tag)
  - **How it works**: When HTMX swaps content (after clicking "Scan for Options"), Flowbite's `initFlowbite()` is called to reinitialize all components including accordions, restoring full click functionality