# Bugs

Pending:
(none)

Completed:
- ✅ We are missing legend labels and axis labels on the "Intrinsic value trends" chart on /scanner/valuations/analytics/ page and on the "Current Intrinsic Values by Method" chart on the /scanner/valuations/comparison/ page
  - **Root Cause**: Dark mode detection was incorrect. The JavaScript was checking for `document.documentElement.classList.contains('dark')` which wasn't reliably detecting the actual page background color. This caused text labels to be rendered in colors that matched the background (invisible labels).
  - **Fixed**: Changed dark mode detection to read actual computed background color from `window.getComputedStyle(document.body).backgroundColor` and check RGB values to determine light vs dark background, then apply contrasting text colors.
  - **Files Changed**:
    - Modified: `templates/scanner/analytics.html` - Updated color detection logic (lines 207-216)
    - Modified: `templates/scanner/valuation_comparison.html` - Updated color detection logic (lines 216-225)
    - Modified: `templates/scanner/stock_history.html` - Updated color detection logic (lines 219-228)
  - **How it works**: JavaScript now reads the actual background color using `getComputedStyle()`, parses the RGB value, and determines if background is dark (RGB < 128) or light. Then applies correct contrasting colors: light text (#f9fafb) on dark backgrounds, dark text (#1f2937) on light backgrounds.
  - **Verification**: Labels now visible on all three chart pages across both light and dark modes. User confirmed fix works after testing with diagnostic tools.

Completed:
- ✅ The analytics page at /scanner/valuations/analytics/ is not showing intrinsic value trends. Total stocks are showing up as 26 but "With history" is 0 and no charts are being drawn
  - **Root Cause**: Field name mismatch between analytics code and ValuationHistory model. Code was attempting to access `eps_intrinsic_value` and `fcf_intrinsic_value`, but the actual model fields are named `intrinsic_value` and `intrinsic_value_fcf`. This caused AttributeError exceptions that were silently caught, preventing any analytics from being calculated.
  - **Fixed**: Corrected all field name references to match the ValuationHistory model definition
  - **Files Changed**:
    - Modified: `scanner/analytics.py` lines 391, 393, 396, 398, 434, 435 (6 occurrences - changed `eps_intrinsic_value` to `intrinsic_value` and `fcf_intrinsic_value` to `intrinsic_value_fcf`)
    - Modified: `scanner/views.py` lines 356, 360 (2 occurrences - same field name corrections in chart data preparation)
  - **How it works**: The ValuationHistory model stores EPS-based valuation in `intrinsic_value` field and FCF-based valuation in `intrinsic_value_fcf` field. The analytics functions now correctly access these fields when extracting historical values for trend calculations, volatility analysis, and CAGR computations.
  - **Verification**:
    - Analytics page now shows "With history: 26/26 stocks" (was 0)
    - All 416 ValuationHistory snapshots are being processed
    - Trend charts are now rendering correctly with multi-line data
    - All 243 tests passing (100% pass rate)
  - **Prevention**: Consider adding type hints to analytics functions, integration tests that verify field access, and enabling mypy static analysis to catch attribute errors before runtime.
- ✅ When navigating to /scanner/valuations/analytics/ I am getting an error "Cannot resolve keyword 'is_active' into field. Choices are: active, created_at, current_eps, current_fcf_per_share, desired_return, eps_growth_rate, eps_multiple, fcf_growth_rate, fcf_multiple, id, intrinsic_value, intrinsic_value_fcf, last_calculation_date, notes, preferred_valuation_method, projection_years, symbol, updated_at, valuation_history"
  - **Root Cause**: The Phase 6.1 analytics implementation used incorrect field name `is_active` instead of `active` when querying CuratedStock model. This is a common naming convention confusion - `is_active` is frequently used in Django models (e.g., Django's User model), but this codebase uses the simpler `active` field name.
  - **Fixed**: Applied minimal surgical fix by replacing `is_active` with `active` in two locations
  - **Files Changed**:
    - Modified: `scanner/views.py` line 713 in `analytics_view()` (changed `is_active=True` to `active=True`)
    - Modified: `scanner/analytics.py` line 482 in `get_portfolio_analytics()` (changed `is_active=True` to `active=True`)
  - **How it works**: The CuratedStock model defines the field as `active` (boolean field for filtering active/inactive stocks). The analytics view and portfolio analytics function now correctly query `CuratedStock.objects.filter(active=True)` to get all active stocks.
  - **Verification**: Confirmed all other locations in codebase (13+ occurrences) correctly use `active=True`. No other instances of `is_active` found in scanner app.
  - **Prevention**: When implementing new features, cross-reference existing model definitions for correct field names. Consider IDE autocomplete to prevent field name typos.
- ✅ The calculate_intrinsic_value command does not actually cache the API return into redis. It looks like we are using Django cache but are not actually defining the Redis cache in settings.
  - **Fixed**: Migrated entire scanner app to Django cache backend with proper Redis configuration
  - **Tasks Completed**: 
    - Task 030: Configured Django Redis cache backend in settings.py
    - Task 031: Refactored Alpha Vantage module to use Django cache (7-day TTL)
    - Task 032: Refactored scanner views to use Django cache (45-min TTL)
    - Task 033: Updated management commands to use Django cache
    - Task 034: Final testing and cleanup - Fixed 5 cache tests, removed old cache keys
  - **Files Changed**:
    - Modified: `wheel_analyzer/settings.py` (added CACHES configuration with Redis backend)
    - Modified: `scanner/alphavantage/util.py` (API calls now cached with consistent key format)
    - Modified: `scanner/alphavantage/technical_analysis.py` (SMA calculations cached)
    - Modified: `scanner/views.py` (all views use Django cache, no direct Redis)
    - Modified: `scanner/management/commands/cron_scanner.py` (uses Django cache)
    - Modified: `scanner/management/commands/calculate_intrinsic_value.py` (removed old cache key cleanup)
    - Created: `scanner/tests/test_django_cache.py` (10 integration tests)
    - Created: `scanner/tests/test_alphavantage_cache.py` (15 unit tests)
    - Updated: `scanner/tests/test_scanner_views.py` (added cache integration tests)
    - Updated: `scanner/tests/test_calculate_intrinsic_value.py` (fixed 5 cache tests to mock requests.get instead of get_market_data)
  - **How it works**: 
    - **Django Cache Backend**: Configured `django.core.cache.backends.redis.RedisCache` in settings with existing Redis URL from .env
    - **Cache TTLs**: Alpha Vantage API data cached for 7 days (604,800 sec), options scan data cached for 45 minutes (2,700 sec)
    - **Cache Keys**: Consistent prefixing - `alphavantage:{function}:{symbol}` for API data, `scanner:*` for options data
    - **Automatic Serialization**: Django cache handles JSON serialization automatically, no manual json.loads/dumps needed
    - **Error Handling**: All cache operations wrapped in try/except, graceful degradation if cache unavailable
    - **Testing**: 40+ new tests validate cache integration using `@patch("django.core.cache.cache")` mocks, no real Redis required for tests
  - **Benefits**:
    - API responses now properly cached (bug fixed ✅)
    - Reduced API consumption (Alpha Vantage rate limits respected)
    - Faster response times (cache hits vs network calls)
    - Consistent with Django best practices
    - Easier to test (mock Django cache instead of Redis client)
    - Single source of cache configuration in settings.py
    - No direct Redis client coupling throughout codebase
- ✅ When navigating to /scanner/ after a scan has already been run, Good/Bad pills were not displaying correctly
  - **Root Cause**: The `index()` view was not including `curated_stocks` in its context. When the template tried to use `{% with stock=curated_stocks|dict_get:ticker %}`, Django treated the missing variable as an empty string `""`, which then triggered the `dict_get` filter warning: "dict_get received non-dict type: str"
  - **Fixed**: Refactored `index()` view to use `get_scan_results()` helper function for consistent context across all views
  - **Files Changed**:
    - Modified: `scanner/views.py` (refactored `index()` view from ~65 lines to ~10 lines by using `get_scan_results()` helper)
    - Modified: `scanner/tests/test_scanner_views.py` (added 3 new tests + fixed 1 existing test mock, total 4 test changes)
  - **How it works**: The `index()` view now calls `get_scan_results()` which fetches both Redis options data AND CuratedStock instances from the database, ensuring `curated_stocks` and `is_local_environment` are always in the context. This provides DRY consistency with `scan_view()` and `scan_status()` views.
  - **Benefits**:
    - Good/Bad pills now display correctly on initial page load
    - Dev warning banner shows consistently in LOCAL environment
    - Code is DRY (Don't Repeat Yourself) - single source of truth for context building
    - Easier to maintain - changes to context structure only need to be made in one place
  - **Testing**: Added 3 comprehensive tests to verify `curated_stocks` is always a dict in context, never None or string. All 6 TestIndexView tests passing.
- ✅ Getting 'str' object has no attribute 'get' on options_results.html line 35 when Redis data expires
  - **Fixed**: Implemented hybrid defense-in-depth approach with backend validation + defensive template handling + Redis error recovery
  - **Files Changed**:
    - Modified: `scanner/views.py` (added try/except blocks for Redis operations in `get_scan_results()` and `index()` views, ensured `curated_stocks` always dict)
    - Modified: `scanner/templatetags/options_extras.py` (added type checking to `dict_get` and `lookup` filters with warning logs)
    - Created: `scanner/tests/test_template_filters.py` (18 unit tests for template filters - all passing)
    - Created: `scanner/tests/test_redis_integration.py` (8 integration tests for Redis failures - all passing)
    - Modified: `scanner/tests/test_scanner_views.py` (added 7 Redis error handling tests - 5 passing, 2 skipped due to test infrastructure)
  - **How it works**: 
    - **Backend Layer**: Views catch Redis exceptions (ConnectionError, TimeoutError, JSONDecodeError) and return safe defaults (empty dicts). The `get_scan_results()` function validates that `curated_stocks` is always a dictionary before returning context. Individual JSON decode errors are caught per-ticker and logged, allowing partial results.
    - **Template Layer**: The `dict_get` filter performs `isinstance()` check before calling `.get()`, returning None for non-dict inputs and logging warnings at WARNING level for debugging.
    - **UX Layer**: When Redis fails, users see "Data temporarily unavailable. Please refresh the page." message and gray "-" badges for stocks (indicating no valuation data). Application remains fully functional.
    - **Defense in depth**: Even if backend validation fails, template filter prevents crashes. Even if template filter fails, existing template logic handles None gracefully by showing gray badges.
    - **Testing**: 33 new tests (18 unit + 8 integration + 7 view tests) verify graceful degradation using Redis mocks. All tests use `@patch` mocks to avoid requiring actual Redis instance during testing.
- ✅ Getting "Reverse for 'scan' not found. 'scan' is not a valid view function or pattern name." when clicking on "Options Scanner" button or navigating to /scanner/
  - **Fixed**: Added missing namespace prefix to URL template tags
  - **Files Changed**:
    - Modified: `templates/scanner/index.html` (changed `{% url 'scan' %}` to `{% url 'scanner:scan' %}`)
    - Modified: `templates/scanner/partials/scan_polling.html` (changed `{% url 'scan_status' %}` to `{% url 'scanner:scan_status' %}`)
  - **How it works**: The scanner app uses `app_name = "scanner"` in `scanner/urls.py`, creating a URL namespace. All URL references must include this namespace prefix (e.g., `scanner:scan` instead of just `scan`). Without the namespace, Django's URL reverser cannot find the matching pattern.
- ✅ The login and logout pages are not using any styling.  They should match the styling of the main site.
  - **Fixed**: Created custom allauth templates with Flowbite/Tailwind styling
  - **Files Changed**:
    - Created: `templates/account/base.html` (minimal layout with logo and "Return to Home" link)
    - Created: `templates/account/login.html` (styled login form with Flowbite components)
    - Created: `templates/account/logout.html` (styled logout confirmation)
  - **How it works**: Django-allauth uses template override system. Templates in `templates/account/` take priority over built-in allauth templates. Auth pages use minimal layout (no navbar) with centered forms, matching site's Flowbite/Tailwind aesthetic.
- ✅ When clicking the "Scan for Options" button, the last run is immediately placed in the status banner.  It should not display the last run information, it should display the current status of the scan.
  - **Fixed**: Set initial status in `scan_view()` before rendering template, removed problematic `elif` clause from template, added completion timestamp
  - **Files Changed**:
    - Modified: `scanner/views.py` (added initial status setting, completion message with timestamp)
    - Modified: `templates/scanner/partials/scan_polling.html` (simplified status logic, removed old error display)
  - **How it works**: When scan starts, `last_run` is immediately set to "Scanning in progress..." before template renders. Template logic simplified to show progress or default message. On completion, timestamp is added: "Scan completed successfully at [timestamp]"
- ✅ The scanner url should only be accessible by logged in users.  Currently any user can navigate to /scanner/
  - **Fixed**: Added `@login_required` decorators to all scanner views
  - **Files Changed**:
    - Modified: `scanner/views.py` (added decorators to 4 views)
    - Modified: `wheel_analyzer/settings.py` (added LOGIN_URL configuration)
  - **How it works**: Django's `@login_required` decorator checks authentication and redirects to `/accounts/login/?next=/scanner/` for unauthenticated users. After login, users are redirected back to the page they originally tried to access.
- ✅ The accordion expansion is not working on the scan_polling.html partial. The user should be able to expand the accordion tab to see the details.
  - **Fixed**: Created `static/js/app.js` with HTMX `afterSwap` event listener that calls Flowbite's `initFlowbite()` function
  - **Files Changed**: 
    - Created: `static/js/app.js`
    - Modified: `templates/base.html` (added script tag)
  - **How it works**: When HTMX swaps content (after clicking "Scan for Options"), Flowbite's `initFlowbite()` is called to reinitialize all components including accordions, restoring full click functionality